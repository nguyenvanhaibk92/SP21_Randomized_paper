clear all; clc; close all;
rand('state', 20)
mesh_array = [2023];

for n = 1:numel(mesh_array)
    N = mesh_array(n);
    N_ITER_array = [1 10]; % number of iterations 1/10/100
    r_array = ceil([N/10 N/5 N/2]); % 10 / 20 / 50 percent of mesh size
    
    % --------- Initial parameters for the N mesh size -----------------------
    noise_level = 0.05;
    load('OBSERVATION_ORIGINAL.mat')
    y_obs = x';
    y_obs = y_obs + max(y_obs) * rand(size(y_obs)) * noise_level;
    
    load('LINEAR_OPERATOR.mat')
    A = AA; % matrix A, Operator
    SIZE_A = size(A); % size of matrix A in R:mxn
    
    load('INITIAL_CONDITION_ORIGINAL.mat')
    true_solution = initial_condition;
    
    Data_var = noise_level^2; Regularization = 500;
    
    C = 1 / Regularization * eye(SIZE_A(2));
    C_INV = Regularization * eye(SIZE_A(2));
    SIGMA = (Data_var) * eye(SIZE_A(1));
    SIGMA_INV = 1 / Data_var * eye(SIZE_A(1));
    % -------------------------------------------------------------------------
    result_RIGHT = zeros(N, numel(r_array), numel(N_ITER_array));
    result_LEFT = zeros(N, numel(r_array), numel(N_ITER_array));
    result_RAN_MAP = zeros(N, numel(r_array), numel(N_ITER_array));
    
    %     for iter = 1:length(N_ITER_array)
    %         N_ITER = N_ITER_array(iter);
    %
    %         for i = 1:length(r_array)
    %             r = r_array(i);
    %
    %             result_RIGHT_in_ITER = zeros(N, 1);
    %             result_LEFT_in_ITER = zeros(N, 1);
    %             result_RAN_MAP_in_ITER = zeros(N, 1);
    %
    %             for j = 1:N_ITER
    %                 %                 %% Using rank one product
    %                 %                 EPSILON = normrnd(0, sqrt(1 / Regularization), [SIZE_A(2), r]);
    %                 %                 LAMBDA = normrnd(0, sqrt(1 / Data_var), [size(y_obs(:), 1), r]);
    %                 %                 sig_rand = normrnd(0, sqrt(Data_var), [size(y_obs(:), 1), r]);
    %                 %
    %                 %                 %% =================== LEFT SKETCHING =====================
    %                 %                 SIGMA_INV_rand = 1 / r * LAMBDA * LAMBDA';
    %                 %                 % Solve the minimization problem using conjugate gradient method.
    %                 %                 RHS = A' * (SIGMA_INV_rand * y_obs(:)); % Construct right hand side
    %                 %                 x_0 = zeros(size(RHS));
    %                 %                 matvecc = @(x) A' * (SIGMA_INV_rand * (A * x)) + C_INV * x;
    %                 %                 max_iters = 10; tol = 1e-5;
    %                 %                 result_LEFT_in_ITER = result_LEFT_in_ITER + 1 / N_ITER * ...
    %                 %                     CG(matvecc, RHS, x_0, max_iters, tol, false);
    %
    %                 %                 %% ============= RANDOMIZED MAP solution ==================
    %                 %                 % Solve the minimization problem using conjugate gradient method.
    %                 %                 RHS = A' * (SIGMA_INV(1, 1) * (y_obs(:) + mean(sig_rand, 2))) + C_INV(1, 1) * mean(EPSILON, 2);
    %                 %                 x_0 = zeros(size(RHS));
    %                 %                 matvecc = @(x) A' * (SIGMA_INV(1, 1) * (A * x)) + C_INV(1, 1) * x;
    %                 % %                 max_iters = 500; tol = 1e-5;
    %                 %                 result_RAN_MAP_in_ITER = result_RAN_MAP_in_ITER + 1 / N_ITER * ...
    %                 %                     CG(matvecc, RHS, x_0, max_iters, tol, false);
    %                 %
    %                 %                 %% ============ RIGHT SKETCHING ===========================
    %                 %                 C_RAND = 1 / r * EPSILON * EPSILON';
    %                 %                 % (1) using CG for solvong Y = (SIGMA + A C A')^{-1} d
    %                 %                 % => (2) Then u_RS  = C A' Y
    %                 %                 % (1) -----------------------------------------------------
    %                 %                 RHS = y_obs(:);
    %                 %                 x_0 = zeros(size(RHS));
    %                 %                 matvecc = @(x) SIGMA(1, 1) * x + A * (C_RAND * (A' * x));
    %                 % %                 max_iters = 500; tol = 1e-5;
    %                 %                 Y = CG(matvecc, RHS, x_0, max_iters, tol, false);
    %                 %                 % (2) -----------------------------------------------------
    %                 %                 u_RS = C_RAND * (A' * (Y));
    %                 %                 result_RIGHT_in_ITER = result_RIGHT_in_ITER + 1 / N_ITER * u_RS;
    %
    %             end
    %
    %             result_RIGHT(:, i, iter) = result_RIGHT_in_ITER;
    %             result_LEFT(:, i, iter) = result_LEFT_in_ITER;
    %             result_RAN_MAP(:, i, iter) = result_RAN_MAP_in_ITER;
    %
    %         end
    %     end
    % u1 = inv(A' * SIGMA_INV * A + C_INV) * ((A * SIGMA_INV * y_obs(:)));
    % Solve the minimization problem using conjugate gradient method.
    u1 = inv(A' * SIGMA_INV * A + C_INV) * ((A * SIGMA_INV * y_obs(:)));
    
    % u2 = (C*A')*(inv(SIGMA + A*C*A') * y_obs);
    u2 = (C*A')*(inv(SIGMA + A*C*A') * y_obs);
end














%% Regularization Parameter determination

al = logspace(-1,6,9);
for n_al = 1:numel(al)
    for n = 1:numel(mesh_array)
        N = mesh_array(n);
        
        
        % --------- Initial parameters for the N mesh size -----------------------
        noise_level = 0.05;
        load('OBSERVATION_ORIGINAL.mat')
        y_obs = x';
        y_obs = y_obs + max(y_obs) * rand(size(y_obs)) * noise_level;
        
        load('LINEAR_OPERATOR.mat')
        A = AA; % matrix A, Operator
        SIZE_A = size(A); % size of matrix A in R:mxn
        
        load('INITIAL_CONDITION_ORIGINAL.mat')
        true_solution = initial_condition;
        
        Data_var = noise_level^2; Regularization = al(n_al);
        
        C = 1 / Regularization * eye(SIZE_A(2));
        C_INV = Regularization * eye(SIZE_A(2));
        SIGMA = (Data_var) * eye(SIZE_A(1));
        SIGMA_INV = 1 / Data_var * eye(SIZE_A(1));

        % Solve the minimization problem using conjugate gradient method.
        u1 = inv(A' * SIGMA_INV * A + C_INV) * ((A * SIGMA_INV * y_obs(:)));
        error(n_al) = norm(u1 - true_solution) / norm(true_solution);
        
        
    end
end








